<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>dynec</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="ch1-ecs.html"><strong aria-hidden="true">1.</strong> ECS</a></li><li class="chapter-item expanded "><a href="ch2-archetypes.html"><strong aria-hidden="true">2.</strong> Archetypes</a></li><li class="chapter-item expanded "><a href="ch3-components.html"><strong aria-hidden="true">3.</strong> Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch3.1-simple-components.html"><strong aria-hidden="true">3.1.</strong> Simple Components</a></li><li class="chapter-item expanded "><a href="ch3.2-isotope-components.html"><strong aria-hidden="true">3.2.</strong> Isotope Components</a></li></ol></li><li class="chapter-item expanded "><a href="ch4-systems.html"><strong aria-hidden="true">4.</strong> Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch4.1-states.html"><strong aria-hidden="true">4.1.</strong> Global and local states</a></li><li class="chapter-item expanded "><a href="ch4.2-component-access.html"><strong aria-hidden="true">4.2.</strong> Component access</a></li><li class="chapter-item expanded "><a href="ch4.3-partitions.html"><strong aria-hidden="true">4.3.</strong> Partitions</a></li><li class="chapter-item expanded "><a href="ch4.4-online-entity-updates.html"><strong aria-hidden="true">4.4.</strong> Online entity updates</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">dynec</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ecs"><a class="header" href="#ecs">ECS</a></h1>
<p>Dynec uses concepts from the ECS (Entity-Component-System) paradigm.
It is a data-oriented programming approach that consists of three core concepts:</p>
<ul>
<li>An <strong>entity</strong> represent different objects.</li>
<li>Different <strong>component</strong>s store data for an entity.</li>
<li><strong>Systems</strong> process the components to execute game logic.</li>
</ul>
<h2 id="data"><a class="header" href="#data">Data</a></h2>
<p>An entity corresponds to an object.
Different components store the data related to an object.
I like visualizing them as rows and columns,
where each row is an entity and each cell is a component of that entity:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Entity #</th><th style="text-align: center">Location</th><th style="text-align: center">Hitpoint</th><th style="text-align: center">Experience</th></tr></thead><tbody>
<tr><td style="text-align: center">0</td><td style="text-align: center">(1, 2, 3)</td><td style="text-align: center">100</td><td style="text-align: center">5</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">(1, 3, 4)</td><td style="text-align: center">80</td><td style="text-align: center">4</td></tr>
<tr><td style="text-align: center">⋮</td><td style="text-align: center">⋮</td><td style="text-align: center">⋮</td><td style="text-align: center">⋮</td></tr>
</tbody></table>
</div>
<p>Everything can be entities!
For example, in a shooters game,
each player and and each bullet is a separate entity.
The components for a bullet are different from those for a player:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Entity #</th><th style="text-align: center">Location</th><th style="text-align: center">Speed</th><th style="text-align: center">Damage</th></tr></thead><tbody>
<tr><td style="text-align: center">0</td><td style="text-align: center">(1, 2.5, 3.5)</td><td style="text-align: center">(0, 0.5, 0.5)</td><td style="text-align: center">20</td></tr>
<tr><td style="text-align: center">⋮</td><td style="text-align: center">⋮</td><td style="text-align: center">⋮</td><td style="text-align: center">⋮</td></tr>
</tbody></table>
</div>
<p>Unlike the traitional OOP pattern where
components of the same object are stored together,
ECS typically stores components of the same type together.
Since data of the same type are usually processed together in bulk,
CPU cache lines have much better efficiency
compared to the traditional random access on the heap.</p>
<h2 id="logic"><a class="header" href="#logic">Logic</a></h2>
<p>A system is a function that processes data.
In a typical game or simulation,
each system are executed once per &quot;cycle&quot; (a.k.a. &quot;ticks&quot;) in the main loop.
Usually, systems are implemented as loops that execute over all entities of a type:</p>
<pre><code>for each bullet entity {
    location[bullet] += speed[bullet]
}
</code></pre>
<p>An ECS framework schedules systems that can be run together on different threads.
Therefore, programs written with ECS are almost lock-free,
so they are more efficient on a multi-threaded environment
compared to traditional approaches that might result in frequent lock contention.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archetypes"><a class="header" href="#archetypes">Archetypes</a></h1>
<p>In traditional ECS frameworks, entities are grouped by the components they have,
e.g. if an entity has a &quot;location&quot; and &quot;speed&quot; component,
it is considered as an entity that can move and
is looped by the system that requests these components.
The set of components created for an entity is called its &quot;archetype&quot;,
which is comparable to &quot;classes&quot; in OOP.</p>
<p>In dynec, entities are <em>statically archetyped</em>,
which means the possible components of an entity is <em>known</em> and <em>fixed</em> from creation.
In the analogy of rows and columns, an archetype is similar to a table.
As such, different archetypes have their own entity IDs.</p>
<p>What if we want to add/remove components for an entity?
dynec still supports optional components,
but the entity is still stored in the same archetype,
so it still appears in the loop when systems iterate over this archetype.
If you would like to loop over entities with certain components,
it is a better idea to split the components to a separate entity with a new archetype
and loop on that archetype instead.
(It is also possible to loop over entities with a specific component,
but joining multiple components is not supported)</p>
<p>Archetypes are typically represented as an unconstructable type (an empty enum)
that is referenced as a type parameter in system declarations.
Therefore, it is possible to reuse the same function
for multiple systems by leaving the archetype as a type parameter.
There is a convenience macro to achieve this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dynec::archetype;

archetype! {
    /// A building entity can store goods inside.
    pub Building;

    /// Each road entity represents a connection between two buildings.
    pub Road;
}
<span class="boring">}
</span></code></pre></pre>
<p>The <a href="https://sof3.github.io/dynec/master/dynec/macro.archetype.html"><code>archetype!</code> macro</a> just declares an empty enum
that implements <a href="https://sof3.github.io/dynec/master/dynec/archetype/trait.Archetype.html"><code>Archetype</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="components"><a class="header" href="#components">Components</a></h1>
<p>Components store the actual data of entities.
In dynec, since entities are statically archetyped,
components are always only usable in specific archetypes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-components"><a class="header" href="#simple-components">Simple components</a></h1>
<p>Simple components are components where
each entity can have at most one instance of the component.
To declare that a type <code>C</code> is a component for entities of archetype <code>A</code>,
implement <a href="https://sof3.github.io/dynec/master/dynec/comp/trait.Simple.html"><code>comp::Simple&lt;A&gt;</code></a> for <code>C</code>.
dynec provides a <a href="https://sof3.github.io/dynec/master/dynec/attr.comp.html">convenience macro</a> for this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[comp(of = Bullet)]
struct Location([f32; 3]);
<span class="boring">}
</span></code></pre></pre>
<p>Since Rust allows implementing the same trait with different type parameters,
<code>C</code> can be used as a component for entities of both <code>A</code> and <code>B</code>
if it implements <code>comp::Simple&lt;A&gt;</code> and <code>comp::Simple&lt;B&gt;</code> separately.
This can be achieved by invoking the macro twice:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dynec::comp;

#[comp(of = Player)]
#[comp(of = Bullet)]
struct Location([f32; 3]);
<span class="boring">}
</span></code></pre></pre>
<p>Note that components are only stored on entities if at least one system uses it.</p>
<h2 id="initializer"><a class="header" href="#initializer">Initializer</a></h2>
<p>Simple components can be equipped with an auto-initializer.
When an entity is created without passing this component,
it is filled with the value returned by the auto-initializer.</p>
<p>The auto-initializer can depend on other simple components
passed by the entity creator or other auto-initializers.
Along with the fact that only components requested from systems get persisted,
this means you can pass a parameter during entity creation,
let other component auto-initializers read from this parameter,
and this parameter will get dropped after entity creation completes.</p>
<p>The auto-initializer can be specified in the macro
either as a closure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dynec::comp;

#[comp(of = Bullet, init = |velocity: &amp;Velocity| Damage(velocity.norm()))]
struct Damage(f32);
<span class="boring">}
</span></code></pre></pre>
<p>or as a function pointer with arity (i.e. number of parameters for the function):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dynec::comp;

fn default_damage(velocity: &amp;Velocity) -&gt; Damage {
    Damage(velocity.norm()) 
}

#[comp(of = Bullet, init = default_damage/1)]
struct Damage(f32);
<span class="boring">}
</span></code></pre></pre>
<h2 id="presence"><a class="header" href="#presence">Presence</a></h2>
<p>A component can be either &quot;required&quot; or &quot;optional&quot;.</p>
<p>The &quot;optional&quot; presence allows components to be missing on some entities.
Therefore, accessing optional components only returns <code>Option&lt;C&gt;</code> instead of <code>C</code>.</p>
<p>&quot;Required&quot; components must either have an auto-initializer
or be passed during entity creation.
This ensures that accessing the component always succeeds for any entities.</p>
<p>Note that entities created during the middle of a tick
are only fully initialized after the end of the tick.
More will be explained in later sections.</p>
<p>Components with &quot;required&quot; presence should <em>both</em>
set <a href="https://sof3.github.io/dynec/master/dynec/comp/trait.Simple.html#associatedconstant.PRESENCE"><code>PRESENCE = SimplePresence::Required</code></a>
<em>and</em> implement <a href="https://sof3.github.io/dynec/master/dynec/comp/trait.Must.html"><code>comp::Must&lt;A&gt;</code></a>.
This is automatically done by passing <code>required</code> in the macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dynec::comp;

#[comp(of = Bullet, required)]
struct Damage(u32);
<span class="boring">}
</span></code></pre></pre>
<h2 id="finalizers"><a class="header" href="#finalizers">Finalizers</a></h2>
<p>A finalizer is a component that prevents an entity from getting deleted.</p>
<p>Yes, I know this may be confusing.
Contrary to finalizers in Java/C#,
a finalizer is a data component instead of a function.
They are actually more similar to <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/finalizers/">finalizers in Kubernetes</a>.
When an entity is flagged for deletion,
dynec checks if all finalizer components for that entity have been removed;
the component data of the entity only get dropped after this check is true.</p>
<p>This gives systems a chance to execute cleanup logic
by reading the component data of the &quot;terminating&quot; entity.
For example, a system that despawns deleted bullets from network players
may implement its logic like the pseudocode below:</p>
<pre><code>for each `Bullet` entity just flagged for deletion:
    read component `NetworkId` for the entity
    broadcast despawn packet to all players
    remove the `Despawn` finalizer component
</code></pre>
<p>Without the finalizer component,
the system would be unable to get the <code>NetworkId</code> for the despawned bullet.</p>
<p>Note that deletion-flagged entities are checked every tick.
To avoid impacting performance due to a growing backlog,
finalizer components should be removed as soon as possible
after deletion has been flagged.</p>
<h2 id="choosing-the-component-type"><a class="header" href="#choosing-the-component-type">Choosing the component type</a></h2>
<p>Systems that write to the same component type cannot execute together.
Furthermore, most games often need to access a single component over a loop,
so avoid putting multiple unrelated fields in the same component type.
Instead, prefer small, often single-field structs,
unless the multiple fields are naturally related,
e.g. positions/RGB values that are always accessed together.</p>
<p>Avoid using <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a> in component types;
instead, use optional components to represent unused fields.
dynec uses a compact bit vector to track the existence of components,
which only takes 1 bit for each component,
while <code>Option</code> needs to preserve alignment and could take up to 64 bits
if the wrapped type requires an alignment of 64 bits (e.g. <code>u64</code>/<code>f64</code>).</p>
<p>Avoid allocating heap memory for each entity component.
In other words, use of <code>Box</code>/<code>Vec</code>/etc should be avoided in component types,
because heap allocation is slow and results in memory fragmentation,
which greatly deteriorates the performance gain provided by ECS.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="isotope-components"><a class="header" href="#isotope-components">Isotope Components</a></h1>
<p>Sometimes we want to store multiple components of the same type on an entity.
For example, we want to store the ingredients that make up a bullet.
The straightforward approach is to use
a <code>Vec&lt;(Element, Weight)&gt;</code>/<code>HashMap&lt;Element, Weight&gt;</code>,
but this is very bad for performance and memory due to many heap allocations,
making ECS almost as slow as OOP.</p>
<p>Isotope components allow us to create components dynamically.
While simple components are identified by their type,
isotope components are identified by the type along with a &quot;discriminant&quot; value,
which is an (optionally newtyped) <code>usize</code> that distinguishes between isotopes.
For example, in the example above,
<code>Element</code> can be used as the discriminant
that distinguishes between different &quot;weight&quot; components,
such that each <code>Weight</code> component refers to a different element.</p>
<p>Like simple components, isotope components are also archetyped,
but they implement <a href="https://sof3.github.io/dynec/master/dynec/comp/trait.Isotope.html"><code>comp::Isotope&lt;A&gt;</code></a> instead,
which can also be achieved through the <code>#[comp]</code> macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[comp(of = Bullet, isotope = Element)]
struct Ingredient(Weight);
<span class="boring">}
</span></code></pre></pre>
<h2 id="choosing-the-discriminant-type"><a class="header" href="#choosing-the-discriminant-type">Choosing the discriminant type</a></h2>
<p>Since a new component storage is created for every new isotope discriminant,
the number of different discriminants must be kept finite.
An example valid usage is to have each discriminant
correspond to one item defined in the game config file,
which is a realistically small number that does not grow with the game over time.</p>
<h2 id="initializer-1"><a class="header" href="#initializer-1">Initializer</a></h2>
<p>As mentioned above, isotope components are just like simple components with the type
<code>HashMap&lt;Discriminant, Value&gt;</code>.
Initializers for isotope components return
iterators of (discriminant, value) tuples instead.</p>
<p>Since the returned iterator involves dynamic discriminant values,
it is not possible to implement <a href="https://sof3.github.io/dynec/master/dynec/comp/trait.Must.html"><code>comp::Must</code></a> for isotope components automatically.
Nevertheless, if the user is sure that all discriminants are populated
in the initializer through exhausting the domain of discriminants,
they can implement this trait manually.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="systems"><a class="header" href="#systems">Systems</a></h1>
<p>Systems contain the actual code that process components.</p>
<p>Systems can be easily created using the <a href="https://sof3.github.io/dynec/master/dynec/attr.system.html"><code>#[system]</code></a> macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dynec::system;

#[system]
fn hello_world() {
    println!(&quot;Hello world!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>After the <code>#[system]</code> macro is applied,
<code>hello_world</code> becomes a unit struct
with the associated functions <code>hello_world::call()</code> and <code>hello_world.build()</code>.
<code>call</code> calls the original function directly,
while <code>build()</code> creates a system descriptor that can be passed to a world builder.</p>
<p>We can package this system into a &quot;bundle&quot;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dynec::world;

pub struct MyBundle;

impl world::Bundle for Bundle {
    fn register(&amp;mut self, builder: &amp;mut world::Builder) {
        builder.schedule(Box::new(hello_world.build()));
        // schedule more systems here
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Then users can add the whole bundle into their world:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut world = dynec::new([
    Box::new(MyBundle),
    // add more bundles here
]);
<span class="boring">}
</span></code></pre></pre>
<p>Alternatively, for non-distribution scenarios (e.g. unit testing),
the <a href="https://sof3.github.io/dynec/master/dynec/macro.system_test.html"><code>system_test!</code></a> macro can be used:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut world = dynec::system_test!(
    hello_world.build();
);
<span class="boring">}
</span></code></pre></pre>
<p>Calling <code>world.execute()</code> would execute the world once.
Run this in your program main loop:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>event_loop.run(|| {
    world.execute(&amp;dynec::tracer::Noop);
})
<span class="boring">}
</span></code></pre></pre>
<p>Since dynec is just a platform-agnostic ECS framework,
it does not integrate with any GUI frameworks to execute the main loop directly.
Usually it is executed at the same rate as the world simulation, screen rendering
or turns (for turn-based games), depending on your requirements.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parameter-local-and-global-states"><a class="header" href="#parameter-local-and-global-states">Parameter, local and global states</a></h1>
<h2 id="local-states"><a class="header" href="#local-states">Local states</a></h2>
<p>Systems can persist values over multiple executions,
known as &quot;local states&quot;:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[system]
fn hello_world(
    #[dynec(local(initial = 0))] counter: &amp;mut i32,
) {
    *counter += 1;
    println!(&quot;counter = {counter}&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><code>0</code> is the initial value of <code>counter</code> before the system is run the first time.
The parameter type must be a reference (<code>&amp;T</code> or <code>&amp;mut T</code>) to the actual stored type.</p>
<p>Calling <code>world.execute()</code> in a row will print the following:</p>
<pre><code class="language-text">counter = 1
counter = 2
counter = 3
...
</code></pre>
<h2 id="parameter-states"><a class="header" href="#parameter-states">Parameter states</a></h2>
<p>The initial value can be passed as a parameter instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[system]
fn hello_world(
    #[dynec(param)] counter: &amp;mut i32,
) {
    *counter += 1;
}

// ...

builder.schedule(Box::new(hello_world.build(123)));
<span class="boring">}
</span></code></pre></pre>
<p>The arguments to <code>.build()</code> are all <code>#[param]</code> parameters in the order they are defined.</p>
<h2 id="global-states"><a class="header" href="#global-states">Global states</a></h2>
<p>States can be shared between multiple systems, identified by their type.
Such types must implement the <a href="https://sof3.github.io/dynec/master/dynec/trait.Global.html"><code>Global</code></a> trait,
which can be done through the <a href="https://sof3.github.io/dynec/master/dynec/attr.global.html"><code>#[global]</code></a> macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[dynec::global(initial = Self::default())]
#[derive(Default)]
struct MyCounter {
    value: i32,
}

#[system]
fn hello_world(
    #[dynec(global)] counter: &amp;mut MyCounter,
) {
    counter.value += 1;
}
<span class="boring">}
</span></code></pre></pre>
<p>The initial value of a global state can also be assigned
in <a href="https://sof3.github.io/dynec/master/dynec/world/trait.Bundle.html#method.register"><code>Bundle::register</code></a> instead
if it is not specified in the <code>#[dynec::global]</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl world::Bundle for Bundle {
    fn register(&amp;mut self, builder: &amp;mut world::Builder) {
        builder.schedule(Box::new(hello_world.build()));
        builder.global(MyCounter { value: 123 });
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The program panics if <code>Bundle::register</code> does not initialize all global states.</p>
<p>Note that <code>&amp;T</code> and <code>&amp;mut T</code> are semantically different for global states.
Multiple systems requesting <code>&amp;T</code> for the same <code>T</code> may run in parallel
in a multi-threaded runtime,
but when a system requesting <code>&amp;mut T</code> is running,
all other <code>&amp;T</code> and <code>&amp;mut T</code>-requesting systems are unschedulable
(but other unrelated systems can still be scheduled).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="component-access"><a class="header" href="#component-access">Component access</a></h1>
<p>As the name &quot;ECS&quot; implies,
the most important feature is to access the &quot;E&quot; and &quot;C&quot; from the &quot;S&quot;.</p>
<h2 id="accessing-simple-components"><a class="header" href="#accessing-simple-components">Accessing simple components</a></h2>
<p>Simple components can be accessed with <a href="https://sof3.github.io/dynec/master/dynec/system/trait.ReadSimple.html"><code>ReadSimple</code></a> or <a href="https://sof3.github.io/dynec/master/dynec/system/trait.WriteSimple.html"><code>WriteSimple</code></a>.
First we declare the components we need, similar to in the previous chapters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dynec::{comp, system};

dynec::archetype!(Bullet);

#[comp(of = Bullet, required)]
struct Position(Vector3&lt;f32&gt;);
#[comp(of = Bullet, required, initial = Velocity(Vector3::zero()))]
struct Velocity(Vector3&lt;f32&gt;);
<span class="boring">}
</span></code></pre></pre>
<p>We want to update position based on the value of the velocity.
Therefore we request reading velocity and writing position:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[system]
fn motion(
    mut position_acc: impl system::WriteSimple&lt;Bullet, Position&gt;,
    velcity_acc: impl system::ReadSimple&lt;Bullet, Velocity&gt;,
) {

}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="partitions"><a class="header" href="#partitions">Partitions</a></h1>
<p>The execution order of systems is actually undefined.
Although the scheduler avoids executing systems requesting conflicting resources
from running concurrently,
it is undefined which system executes first.
For example, consider the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[global(initial = Self::default())]
struct Clock {
    ticks: u32,
}

#[system]
fn update_clock(#[dynec(global)] clock: &amp;mut Clock) {
    clock.ticks += 1;
}

#[system]
fn render_status(
    #[dynec(global)] status: &amp;mut StatusBar,
    #[dynec(global)] clock: &amp;Clock,
) {
    status.set_text(format!(&quot;Current time: {}&quot;, clock.ticks));
}

#[system]
fn render_progress(
    #[dynec(global)] progress: &amp;mut ProgressBar,
    #[dynec(global)] clock: &amp;Clock,
) {
    progress.set_progress(clock.ticks);
}
<span class="boring">}
</span></code></pre></pre>
<p>It is actually possible that <code>render_status</code> is executed before <code>update_clock</code>
but <code>render_progress</code> is executed afterwards,
in which case the progress bar and the status bar have different values in the end.</p>
<p>To avoid this problem, we introduce <em>partitions</em>,
which can ensure some systems are executed before some others.</p>
<p>A partition is any thread-safe value that implements <code>Debug + Eq + Hash</code>.
Any two equivalent values (with the same type) are considered to be the same partition.
So for the example above, we can create a <code>ClockUpdatedPartition</code> type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, PartialEq, Eq, Hash)]
struct ClockUpdatedPartition;

#[system(before(ClockUpdatedPartition))]
fn update_clock(#[dynec(global)] clock: &amp;mut Clock) {
    clock.ticks += 1;
}

#[system(after(ClockUpdatedPartition))]
fn render_status(
    #[dynec(global)] status: &amp;mut StatusBar,
    #[dynec(global)] clock: &amp;Clock,
) {
    status.set_text(format!(&quot;Current time: {}&quot;, clock.ticks));
}

#[system(after(ClockUpdatedPartition))]
fn render_progress(
    #[dynec(global)] progress: &amp;mut ProgressBar,
    #[dynec(global)] clock: &amp;Clock,
) {
    progress.set_progress(clock.ticks);
}
<span class="boring">}
</span></code></pre></pre>
<p>Thus, <code>update_clock</code> is already executed when <code>ClockUpdatedPartition</code> is complete.
Then <code>render_status</code> and <code>render_progress</code> are only executed
after the partition is complete,
so they render the value of the updated clock.</p>
<p>If the scheduler detected a cyclic dependency,
it panics with an error like this:</p>
<pre><code class="language-text">Scheduled systems have a cyclic dependency: thread-safe system #0 (main::update_clock) -&gt; partition #0 (main::ClockUpdatedPartition) -&gt; thread-safe system #0 (main::update_clock)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="online-entity-updates"><a class="header" href="#online-entity-updates">Online entity updates</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
