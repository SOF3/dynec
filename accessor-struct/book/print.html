<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>dynec</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="ch1-ecs.html"><strong aria-hidden="true">1.</strong> ECS</a></li><li class="chapter-item expanded "><a href="ch2-archetypes.html"><strong aria-hidden="true">2.</strong> Archetypes</a></li><li class="chapter-item expanded "><a href="ch3-components.html"><strong aria-hidden="true">3.</strong> Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch3.1-simple-components.html"><strong aria-hidden="true">3.1.</strong> Simple Components</a></li><li class="chapter-item expanded "><a href="ch3.2-isotope-components.html"><strong aria-hidden="true">3.2.</strong> Isotope Components</a></li></ol></li><li class="chapter-item expanded "><a href="ch4-systems.html"><strong aria-hidden="true">4.</strong> Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch4.1-states.html"><strong aria-hidden="true">4.1.</strong> Global and local states</a></li><li class="chapter-item expanded "><a href="ch4.2-component-access.html"><strong aria-hidden="true">4.2.</strong> Component access</a></li><li class="chapter-item expanded "><a href="ch4.3-partitions.html"><strong aria-hidden="true">4.3.</strong> Partitions</a></li><li class="chapter-item expanded "><a href="ch4.4-online-entity-updates.html"><strong aria-hidden="true">4.4.</strong> Online entity updates</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">dynec</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ecs"><a class="header" href="#ecs">ECS</a></h1>
<p>Dynec uses concepts from the ECS (Entity-Component-System) paradigm.
It is a data-oriented programming approach that consists of three core concepts:</p>
<ul>
<li>An <strong>entity</strong> represent different objects.</li>
<li>Different <strong>component</strong>s store data for an entity.</li>
<li><strong>Systems</strong> process the components to execute game logic.</li>
</ul>
<h2 id="data"><a class="header" href="#data">Data</a></h2>
<p>An intuitive way to visualize entities and components
would be a table,
where each row is an entity and each cell is a component of that entity:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Entity #</th><th style="text-align: center">Location</th><th style="text-align: center">Hitpoint</th><th style="text-align: center">Experience</th></tr></thead><tbody>
<tr><td style="text-align: center">0</td><td style="text-align: center">(1, 2, 3)</td><td style="text-align: center">100</td><td style="text-align: center">5</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">(1, 3, 4)</td><td style="text-align: center">80</td><td style="text-align: center">4</td></tr>
<tr><td style="text-align: center">⋮</td><td style="text-align: center">⋮</td><td style="text-align: center">⋮</td><td style="text-align: center">⋮</td></tr>
</tbody></table>
</div>
<p>Everything can be an entity!
For example, in a shooters game,
each player is an entity,
each bullet is an entity,
and even each inventory slot of the player may be an entity as well.</p>
<p>The components for a bullet are different from those for a player:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Entity #</th><th style="text-align: center">Location</th><th style="text-align: center">Velocity</th><th style="text-align: center">Damage</th></tr></thead><tbody>
<tr><td style="text-align: center">0</td><td style="text-align: center">(1, 2.5, 3.5)</td><td style="text-align: center">(0, 0.5, 0.5)</td><td style="text-align: center">20</td></tr>
<tr><td style="text-align: center">⋮</td><td style="text-align: center">⋮</td><td style="text-align: center">⋮</td><td style="text-align: center">⋮</td></tr>
</tbody></table>
</div>
<h2 id="logic"><a class="header" href="#logic">Logic</a></h2>
<p>A system is a function that processes the data.
In a typical simulation program,
each system is executed once per &quot;cycle&quot; (a.k.a. &quot;ticks&quot;) in a main loop.
Usually, systems are implemented as loops that execute over all entities of a type:</p>
<pre><code>for each bullet entity {
    location[bullet] += speed[bullet]
}
</code></pre>
<p>An ECS framework schedules systems to run on different threads.
Therefore, programs written with ECS are almost lock-free.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archetypes"><a class="header" href="#archetypes">Archetypes</a></h1>
<p>In traditional ECS, the type of an entity is identified by the components it has.
For example, an entity is considered to be &quot;moveable&quot;
if it has the &quot;location&quot; and &quot;speed&quot; components.
Systems iterate over the &quot;moveable&quot; entities by performing a &quot;join query&quot;
that intersects the entities with a &quot;location&quot; and the entities with a &quot;speed&quot;.
Thus, an entity type is effectively a subtype of any combination of its components,
e.g. both &quot;player&quot; and &quot;bullet&quot; are subtypes of &quot;moveable&quot;.</p>
<p>Dynec takes a different approach on entity typing.
Dynec requires the type of an entity (its &quot;archeytpe&quot;) to be
<em>known</em> during creation and <em>immutable</em> after creation (&quot;statically archetyped&quot;).
A reference to an entity always contains the archetype.</p>
<p>Dynec still supports adding/removing components for an entity,
but this is implemented by making the component optional (effectively <code>Option&lt;Comp&gt;</code>)
instead of changing its archetype.
Adding/removing a component would not affect
systems iterating over all entities of its archetype.</p>
<p>To iterate over entities with only a specific component,
the suggested approach is to split the components
to a separate entity with a new archetype
and iterate over entities with that archetype instead.
(It is also possible to iterate over entities with a specific component,
but it is less efficient than iterate over all entities of the same component,
and joining multiple components is not supported)</p>
<p>Archetypes are typically represented as an unconstructable type (an empty enum)
referenced as a type parameter in system declarations.
Therefore, multiple systems can reuse the same generic function
where the archetype is a type parameter,
achieving something similar to the &quot;subtyping&quot; approach.
Nevertheless, Dynec discourages treating archetypes as subtypes
and encourages splitting shared components to an entity.
Therefore, it is possible to reuse the same function
for multiple systems by leaving the archetype as a type parameter.</p>
<p>An archetype can be declared through the <a href="https://sof3.github.io/dynec/master/dynec/macro.archetype.html"><code>dynec::archetype</code></a> macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>dynec::archetype! {
    /// A building entity can store goods inside.
    pub Building;

    /// Each road entity represents a connection between two buildings.
    pub Road;
}
<span class="boring">}
</span></code></pre></pre>
<p>There is nothing magical here;
each line just declares an empty enum and implements <a href="https://sof3.github.io/dynec/master/dynec/archetype/trait.Archetype.html"><code>Archetype</code></a> for it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="components"><a class="header" href="#components">Components</a></h1>
<p>Components store the actual data for an entity.
In Dynec, since entities are statically archetyped,
a component is only meaningful when specified togethre with an archetype.</p>
<p>There are two kinds of components, namely &quot;simple components&quot; and &quot;isotope components&quot;.
For simple components, each entity cannot have
more than one instance for each component type.
Meanwhile, isotope components allow storing multiple instances
of the same component type for the same entity.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-components"><a class="header" href="#simple-components">Simple components</a></h1>
<p>Simple components are components where
each entity can have at most one instance of the component.
A type can be used as a simple component for entities of archetype <code>A</code>
if it implements <a href="https://sof3.github.io/dynec/master/dynec/comp/trait.Simple.html"><code>comp::Simple&lt;A&gt;</code></a>.
Dynec provides <a href="https://sof3.github.io/dynec/master/dynec/attr.comp.html">a convenience macro</a> to do this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[comp(of = Bullet)]
struct Location([f32; 3]);
<span class="boring">}
</span></code></pre></pre>
<p>This declares a simple component called <code>Location</code>
that can be used on <code>Bullet</code> entities.</p>
<p>The same type can be reused as components for multiple archetypes.
by applying the macro multiple times:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dynec::comp;

#[comp(of = Player)]
#[comp(of = Bullet)]
struct Location([f32; 3]);
<span class="boring">}
</span></code></pre></pre>
<h2 id="initializer"><a class="header" href="#initializer">Initializer</a></h2>
<p>Simple components can be equipped with an auto-initializer.
If an entity is created without specifying this component,
the auto-initializer is called to fill the component.</p>
<p>The auto-initializer can read values of other simple components,
either specified by the entity creator or returned by another auto-initializer.
Since Dynec does not persist a component
unless it is requested by a system or explicitly registered,
this means you can pass a temporary component during entity creation,
use its value in other component auto-initializers,
and this temporary component gets dropped after entity creation completes.</p>
<p>The auto-initializer can be specified in the macro
either as a closure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dynec::comp;

#[comp(of = Bullet, init = |velocity: &amp;Velocity| Damage(velocity.norm()))]
struct Damage(f32);
<span class="boring">}
</span></code></pre></pre>
<p>or as a function pointer with arity notation
(i.e. write the number of parameters for the function after a <code>/</code>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dynec::comp;

fn default_damage(velocity: &amp;Velocity) -&gt; Damage {
    Damage(velocity.norm()) 
}

#[comp(of = Bullet, init = default_damage/1)]
struct Damage(f32);
<span class="boring">}
</span></code></pre></pre>
<h2 id="presence"><a class="header" href="#presence">Presence</a></h2>
<p>A component is either <code>Required</code> or <code>Optional</code>.</p>
<p><code>Optional</code> components may be missing on some entities.
Accessing optional components returns <code>Option&lt;C&gt;</code> instead of <code>C</code>.</p>
<p><code>Required</code> components must either have an auto-initializer
or be passed during entity creation.
This ensures that accessing the component always succeeds for an initialized entity;
optimizations such as chunk iteration are only possible for <code>Required</code> components.
Nevertheless, components are <strong>always</strong> missing
for uninitialized entities created during the middle of a tick;
more will be explained in later sections.</p>
<p>A <code>Required</code> component must <em>both</em>
set <a href="https://sof3.github.io/dynec/master/dynec/comp/trait.Simple.html#associatedconstant.PRESENCE"><code>PRESENCE = SimplePresence::Required</code></a>
<em>and</em> implement <a href="https://sof3.github.io/dynec/master/dynec/comp/trait.Must.html"><code>comp::Must&lt;A&gt;</code></a>.
This is automatically done by specifying <code>required</code> in the <code>#[comp]</code> macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dynec::comp;

#[comp(of = Bullet, required)]
struct Damage(u32);
<span class="boring">}
</span></code></pre></pre>
<h2 id="finalizers"><a class="header" href="#finalizers">Finalizers</a></h2>
<p>A finalizer component is a component that prevents an entity from getting deleted.</p>
<blockquote>
<p>Yes, I know this may be confusing.
Contrary to finalizers in Java/C#,
a finalizer is a data component instead of a function.
They are actually more similar to <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/finalizers/">finalizers in Kubernetes</a>.</p>
</blockquote>
<p>When an entity is flagged for deletion,
Dynec checks if all finalizer components for that entity have been removed.
If there is at least one present finalizer component for the entity,
the entity would instead be scheduled to asynchronously delete
when all finalizer components have been unset.</p>
<p>This gives systems a chance to execute cleanup logic
by reading the component data of the &quot;terminating&quot; entity.
For example, a system that despawns deleted bullets from network players
may get a chance to handle bullet deletion:</p>
<pre><code class="language-text">for each `Bullet` entity flagged for deletion:
    if `Despawn` componnent is set
        read component `NetworkId` for the entity
        broadcast despawn packet to all players
        unset the `Despawn` finalizer component
</code></pre>
<p>Without the finalizer component,
the system would be unable to get the <code>NetworkId</code> for the despawned bullet
since the component has been cleaned up.</p>
<p>Note that deletion-flagged entities are checked every tick.
To avoid a growing backlog of entities to delete,
finalizer components should be removed as soon as possible
after deletion has been flagged.</p>
<h2 id="best-practices"><a class="header" href="#best-practices">Best practices</a></h2>
<h3 id="small-component-structs"><a class="header" href="#small-component-structs">Small component structs</a></h3>
<p>Dynec prevents systems that write to the same component type
from executing concurrently to avoid data race.
In reality, most systems only need to access a subset of fields,
so avoid putting many unrelated fields in the same component type.
Instead, prefer small, often single-field structs,
unless the multiple fields are naturally related,
e.g. positions/RGB values that are always accessed together.</p>
<h3 id="optional-types"><a class="header" href="#optional-types">Optional types</a></h3>
<p>Avoid using <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a> in component types;
instead, use optional components to represent unused fields.
By default, Dynec uses a compact bit vector to track the existence of components,
which only takes 1 bit per component.
Meanwhile, <code>Option&lt;T&gt;</code> needs to preserve the alignment of <code>T</code>,
so a type like <code>Option&lt;f64&gt;</code> is 128 bits large
(1 bit for <code>None</code>, 63 bits for alignment padding, 64 bits for the actual data),
which is very wasteful of memory.</p>
<h3 id="heap-allocated-types"><a class="header" href="#heap-allocated-types">Heap-allocated types</a></h3>
<p>Minimize external (heap) memory referenced in entity components.
Heap allocation/deallocation is costly,
and the memory allocated is randomly located in the memory,
which means the CPU needs to keep loading new memory pages
into its memory cache layers
and greatly worsens performance.
Dynec stores component data in (almost) contiguous memory
and prefers processing adjacent entities in the same CPU,
so keeping all relevant data in the component structure is preferred.</p>
<p>While this is inevitable for some component types like strings,
types like <code>Vec</code> can often be avoided:</p>
<ul>
<li>If each entity has a similar structure of items
(i.e. <code>comp[0]</code> for entity 1 has the same logic as <code>comp[0]</code> for entity 2),
use isotope components instead.</li>
<li>If the items in the vector are unstructured
(i.e. <code>comp[0]</code> for entity 1 has the same logic as <code>comp[1]</code> for entit y2),
consider turning each item into an entity and process the entity instead.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="isotope-components"><a class="header" href="#isotope-components">Isotope Components</a></h1>
<p>Sometimes we want to store multiple components of the same type on an entity.
For example, we want to store the ingredients that make up a bullet.
The straightforward approach is to use
a <code>Vec&lt;(Element, Weight)&gt;</code>/<code>HashMap&lt;Element, Weight&gt;</code>,
but this is very bad for performance and memory due to many heap allocations,
making ECS almost as slow as OOP.</p>
<p>Isotope components allow us to create components dynamically.
While simple components are identified by their type,
isotope components are identified by the type along with a &quot;discriminant&quot; value,
which is an (optionally newtyped) <code>usize</code> that distinguishes between isotopes.
For example, in the example above,
<code>Element</code> can be used as the discriminant
that distinguishes between different &quot;weight&quot; components,
such that each <code>Weight</code> component refers to a different element.</p>
<p>Like simple components, isotope components are also archetyped,
but they implement <a href="https://sof3.github.io/dynec/master/dynec/comp/trait.Isotope.html"><code>comp::Isotope&lt;A&gt;</code></a> instead,
which can also be achieved through the <code>#[comp]</code> macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[comp(of = Bullet, isotope = Element)]
struct Ingredient(Weight);
<span class="boring">}
</span></code></pre></pre>
<h2 id="choosing-the-discriminant-type"><a class="header" href="#choosing-the-discriminant-type">Choosing the discriminant type</a></h2>
<p>Since a new component storage is created for every new isotope discriminant,
the number of different discriminants must be kept finite.
An example valid usage is to have each discriminant
correspond to one item defined in the game config file,
which is a realistically small number that does not grow with the game over time.</p>
<h2 id="initializer-1"><a class="header" href="#initializer-1">Initializer</a></h2>
<p>As mentioned above, isotope components are just like simple components with the type
<code>HashMap&lt;Discriminant, Value&gt;</code>.
Initializers for isotope components return
iterators of (discriminant, value) tuples instead.</p>
<p>Since the returned iterator involves dynamic discriminant values,
it is not possible to implement <a href="https://sof3.github.io/dynec/master/dynec/comp/trait.Must.html"><code>comp::Must</code></a> for isotope components automatically.
Nevertheless, if the user is sure that all discriminants are populated
in the initializer through exhausting the domain of discriminants,
they can implement this trait manually.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="systems"><a class="header" href="#systems">Systems</a></h1>
<p>Systems contain the actual code that process components.</p>
<p>Systems can be easily created using the <a href="https://sof3.github.io/dynec/master/dynec/attr.system.html"><code>#[system]</code></a> macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dynec::system;

#[system]
fn hello_world() {
    println!(&quot;Hello world!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>After the <code>#[system]</code> macro is applied,
<code>hello_world</code> becomes a unit struct
with the associated functions <code>hello_world::call()</code> and <code>hello_world.build()</code>.
<code>call</code> calls the original function directly,
while <code>build()</code> creates a system descriptor that can be passed to a world builder.</p>
<p>We can package this system into a &quot;bundle&quot;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dynec::world;

pub struct MyBundle;

impl world::Bundle for Bundle {
    fn register(&amp;mut self, builder: &amp;mut world::Builder) {
        builder.schedule(Box::new(hello_world.build()));
        // schedule more systems here
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Then users can add the whole bundle into their world:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut world = dynec::new([
    Box::new(MyBundle),
    // add more bundles here
]);
<span class="boring">}
</span></code></pre></pre>
<p>Alternatively, for non-distribution scenarios (e.g. unit testing),
the <a href="https://sof3.github.io/dynec/master/dynec/macro.system_test.html"><code>system_test!</code></a> macro can be used:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut world = dynec::system_test!(
    hello_world.build();
);
<span class="boring">}
</span></code></pre></pre>
<p>Calling <code>world.execute()</code> would execute the world once.
Run this in your program main loop:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>event_loop.run(|| {
    world.execute(&amp;dynec::tracer::Noop);
})
<span class="boring">}
</span></code></pre></pre>
<p>Since dynec is just a platform-agnostic ECS framework,
it does not integrate with any GUI frameworks to execute the main loop directly.
Usually it is executed at the same rate as the world simulation, screen rendering
or turns (for turn-based games), depending on your requirements.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parameter-local-and-global-states"><a class="header" href="#parameter-local-and-global-states">Parameter, local and global states</a></h1>
<h2 id="local-states"><a class="header" href="#local-states">Local states</a></h2>
<p>Systems can persist values over multiple executions,
known as &quot;local states&quot;:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[system]
fn hello_world(
    #[dynec(local(initial = 0))] counter: &amp;mut i32,
) {
    *counter += 1;
    println!(&quot;counter = {counter}&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><code>0</code> is the initial value of <code>counter</code> before the system is run the first time.
The parameter type must be a reference (<code>&amp;T</code> or <code>&amp;mut T</code>) to the actual stored type.</p>
<p>Calling <code>world.execute()</code> in a row will print the following:</p>
<pre><code class="language-text">counter = 1
counter = 2
counter = 3
...
</code></pre>
<h2 id="parameter-states"><a class="header" href="#parameter-states">Parameter states</a></h2>
<p>The initial value can be passed as a parameter instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[system]
fn hello_world(
    #[dynec(param)] counter: &amp;mut i32,
) {
    *counter += 1;
}

// ...

builder.schedule(Box::new(hello_world.build(123)));
<span class="boring">}
</span></code></pre></pre>
<p>The arguments to <code>.build()</code> are all <code>#[param]</code> parameters in the order they are defined.</p>
<h2 id="global-states"><a class="header" href="#global-states">Global states</a></h2>
<p>States can be shared between multiple systems, identified by their type.
Such types must implement the <a href="https://sof3.github.io/dynec/master/dynec/trait.Global.html"><code>Global</code></a> trait,
which can be done through the <a href="https://sof3.github.io/dynec/master/dynec/attr.global.html"><code>#[global]</code></a> macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[dynec::global(initial = Self::default())]
#[derive(Default)]
struct MyCounter {
    value: i32,
}

#[system]
fn hello_world(
    #[dynec(global)] counter: &amp;mut MyCounter,
) {
    counter.value += 1;
}
<span class="boring">}
</span></code></pre></pre>
<p>The initial value of a global state can also be assigned
in <a href="https://sof3.github.io/dynec/master/dynec/world/trait.Bundle.html#method.register"><code>Bundle::register</code></a> instead
if it is not specified in the <code>#[dynec::global]</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl world::Bundle for Bundle {
    fn register(&amp;mut self, builder: &amp;mut world::Builder) {
        builder.schedule(Box::new(hello_world.build()));
        builder.global(MyCounter { value: 123 });
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The program panics if <code>Bundle::register</code> does not initialize all global states.</p>
<p>Note that <code>&amp;T</code> and <code>&amp;mut T</code> are semantically different for global states.
Multiple systems requesting <code>&amp;T</code> for the same <code>T</code> may run in parallel
in a multi-threaded runtime,
but when a system requesting <code>&amp;mut T</code> is running,
all other <code>&amp;T</code> and <code>&amp;mut T</code>-requesting systems are unschedulable
(but other unrelated systems can still be scheduled).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="component-access"><a class="header" href="#component-access">Component access</a></h1>
<p>As the name &quot;ECS&quot; implies,
the most important feature is to access the &quot;E&quot; and &quot;C&quot; from the &quot;S&quot;.</p>
<h2 id="accessing-simple-components"><a class="header" href="#accessing-simple-components">Accessing simple components</a></h2>
<p>Simple components can be accessed with <a href="https://sof3.github.io/dynec/master/dynec/system/trait.ReadSimple.html"><code>ReadSimple</code></a> or <a href="https://sof3.github.io/dynec/master/dynec/system/trait.WriteSimple.html"><code>WriteSimple</code></a>.
First we declare the components we need, similar to in the previous chapters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dynec::{comp, system};

dynec::archetype!(Bullet);

#[comp(of = Bullet, required)]
struct Position(Vector3&lt;f32&gt;);
#[comp(of = Bullet, required, initial = Velocity(Vector3::zero()))]
struct Velocity(Vector3&lt;f32&gt;);
<span class="boring">}
</span></code></pre></pre>
<p>We want to update position based on the value of the velocity.
Therefore we request reading velocity and writing position:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[system]
fn motion(
    mut position_acc: impl system::WriteSimple&lt;Bullet, Position&gt;,
    velcity_acc: impl system::ReadSimple&lt;Bullet, Velocity&gt;,
) {

}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="partitions"><a class="header" href="#partitions">Partitions</a></h1>
<p>The execution order of systems is actually undefined.
Although the scheduler avoids executing systems requesting conflicting resources
from running concurrently,
it is undefined which system executes first.
For example, consider the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[global(initial = Self::default())]
struct Clock {
    ticks: u32,
}

#[system]
fn update_clock(#[dynec(global)] clock: &amp;mut Clock) {
    clock.ticks += 1;
}

#[system]
fn render_status(
    #[dynec(global)] status: &amp;mut StatusBar,
    #[dynec(global)] clock: &amp;Clock,
) {
    status.set_text(format!(&quot;Current time: {}&quot;, clock.ticks));
}

#[system]
fn render_progress(
    #[dynec(global)] progress: &amp;mut ProgressBar,
    #[dynec(global)] clock: &amp;Clock,
) {
    progress.set_progress(clock.ticks);
}
<span class="boring">}
</span></code></pre></pre>
<p>It is actually possible that <code>render_status</code> is executed before <code>update_clock</code>
but <code>render_progress</code> is executed afterwards,
in which case the progress bar and the status bar have different values in the end.</p>
<p>To avoid this problem, we introduce <em>partitions</em>,
which can ensure some systems are executed before some others.</p>
<p>A partition is any thread-safe value that implements <code>Debug + Eq + Hash</code>.
Any two equivalent values (with the same type) are considered to be the same partition.
So for the example above, we can create a <code>ClockUpdatedPartition</code> type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, PartialEq, Eq, Hash)]
struct ClockUpdatedPartition;

#[system(before(ClockUpdatedPartition))]
fn update_clock(#[dynec(global)] clock: &amp;mut Clock) {
    clock.ticks += 1;
}

#[system(after(ClockUpdatedPartition))]
fn render_status(
    #[dynec(global)] status: &amp;mut StatusBar,
    #[dynec(global)] clock: &amp;Clock,
) {
    status.set_text(format!(&quot;Current time: {}&quot;, clock.ticks));
}

#[system(after(ClockUpdatedPartition))]
fn render_progress(
    #[dynec(global)] progress: &amp;mut ProgressBar,
    #[dynec(global)] clock: &amp;Clock,
) {
    progress.set_progress(clock.ticks);
}
<span class="boring">}
</span></code></pre></pre>
<p>Thus, <code>update_clock</code> is already executed when <code>ClockUpdatedPartition</code> is complete.
Then <code>render_status</code> and <code>render_progress</code> are only executed
after the partition is complete,
so they render the value of the updated clock.</p>
<p>If the scheduler detected a cyclic dependency,
it panics with an error like this:</p>
<pre><code class="language-text">Scheduled systems have a cyclic dependency: thread-safe system #0 (main::update_clock) -&gt; partition #0 (main::ClockUpdatedPartition) -&gt; thread-safe system #0 (main::update_clock)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="online-entity-updates"><a class="header" href="#online-entity-updates">Online entity updates</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
