<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Converts a function into a system."><title>system in dynec::macros - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-9ee3a5e31a2afa3e.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="dynec" data-themes="" data-resource-suffix="" data-rustdoc-version="1.76.0-nightly (3a85a5cfe 2023-11-20)" data-channel="nightly" data-search-js="search-d23a059ec093b287.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-f06f02fd918e3bb3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc attr"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../dynec/index.html">dynec</a><span class="version">0.2.0-alpha.1</span></h2></div><div class="sidebar-elems"><h2><a href="index.html">In dynec::macros</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Attribute Macro <a href="../index.html">dynec</a>::<wbr><a href="index.html">macros</a>::<wbr><a class="attr" href="#">system</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../src/dynec_codegen/lib.rs.html#54">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>#[system]</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Converts a function into a system.</p>
<p>This macro converts the function into a unit struct with the same name
that implements <a href="../system/struct.Spec.html" title="struct dynec::system::Spec"><code>system::Spec</code></a>.
The unit struct also derefs to a function pointer,
so it is still possible to call the function directly (mainly useful in unit tests)
without any change in the signature.
However it is not recommended to call this function directly in production code.</p>
<h2 id="options"><a href="#options">Options</a></h2>
<p>Options are applied behind the attribute name in the form <code>#[system(...)]</code>.
Multiple options are separated by commas.</p>
<h3 id="name--expr"><a href="#name--expr"><code>name = $expr</code></a></h3>
<p>Sets the <a href="../system/struct.Spec.html#structfield.debug_name" title="field dynec::system::Spec::debug_name">name</a> of the system to <code>$expr</code>.
By default, the name is <code>concat!(module_path!(), &quot;::&quot;, $function_identifier)</code>.</p>
<p>The <code>$expr</code> can read the local and param states of the system directly.
Since the debug name is only used for display purposes,
it is allowed (although confusing to the programmer) to use mutable states in the name.
It is unspecified whether debug messages use the initial debug name or the updated state.</p>
<h3 id="beforeexpr1-expr2--and-afterexpr1-expr2-"><a href="#beforeexpr1-expr2--and-afterexpr1-expr2-"><code>before($expr1, $expr2, ...)</code> and <code>after($expr1, $expr2, ...)</code></a></h3>
<p>Indicates that the system must be executed
before/after all <a href="../system/partition/trait.Partition.html" title="trait dynec::system::partition::Partition">partitions</a> given in the expressions.</p>
<p>Similar to <code>name</code>, the expressions can read local and param states directly.
However, only the expressions are only resolved once before the first run of the system,
so mutating states has no effect on the system schedule.</p>
<h2 id="parameters"><a href="#parameters">Parameters</a></h2>
<p>Each parameter of a system function has a special meaning:</p>
<h3 id="local-states"><a href="#local-states">Local states</a></h3>
<p>Parameters with the attribute <code>#[dynec(local(initial = xxx))]</code> are “local states”,
where <code>xxx</code> is an expression that evaluates to the initial value of the state.</p>
<p>Local states must take the type <code>&amp;T</code> or <code>&amp;mut T</code>,
where <code>T</code> is the actual stored state.
The mutated state persists for each instance of the system.</p>
<p>Use global states instead if the local state needs to be accessed from multiple systems.</p>
<p>Since entity references can be stored in local states,
the struct used to store local states also implements
<a href="../entity/referrer/trait.Referrer.html" title="trait dynec::entity::referrer::Referrer"><code>entity::Referrer</code></a>.
The corresponding <code>entity</code> and <code>not_entity</code> attributes can be inside the <code>local()</code> instead.</p>
<p>Unlike global states, local states do not need to specify thread safety.
Thread safety of local states is checked at compile time
when the system is passed to the scheduler.</p>
<h4 id="syntax-reference"><a href="#syntax-reference">Syntax reference</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[dynec(local(
    <span class="comment">// Required, the initial value of the local state.
    </span>initial = <span class="macro-nonterminal">$expr</span>,
    <span class="comment">// Optional, equivalent to #[entity] in #[derive(EntityRef)].
    </span>entity,
    <span class="comment">// Optional, equivalent to #[not_entity] in #[derive(EntityRef)].
    </span>not_entity,
))]</span></code></pre></div>
<h3 id="param-states"><a href="#param-states">Param states</a></h3>
<p>Parameters with the attribute <code>#[dynec(param)]</code> are “param states”.
The user has to pass initial values for param states in the <code>.build()</code> method.
Param states behave identically to local states
except for different definition location of the initial value.</p>
<p>It is typically used to initialize systems with resources that cannot be created statically
(e.g. system canvas resources),
or to schedule multiple systems declared from the same function
(e.g. working on multiple discriminants of an isotope component).</p>
<p>Similar to local states, param states can also use <code>entity</code> and <code>not_entity</code>.</p>
<h4 id="syntax-reference-1"><a href="#syntax-reference-1">Syntax reference</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[dynec(param(
    <span class="comment">// Optional, equivalent to #[entity] in #[derive(EntityRef)].
    </span>entity,
    <span class="comment">// Optional, equivalent to #[not_entity] in #[derive(EntityRef)].
    </span>not_entity,
))]</span></code></pre></div>
<h3 id="global-states"><a href="#global-states">Global states</a></h3>
<p>Parameters with the attribute <code>#[dynec(global)]</code> are “global states”.
Global states are shared scalar data between multiple systems.
See <a href="../global/trait.Global.html" title="trait dynec::global::Global"><code>Global</code></a> for more information.</p>
<p>Thread-unsafe (non-<code>Send + Sync</code>) global states must be declared as
<code>#[dynec(global(thread_local))]</code> to indicate that
the global state can only be accessed from the main thread.
As a result, systems that request thread-local global states
will only be scheduled on the main thread.</p>
<h4 id="syntax-reference-2"><a href="#syntax-reference-2">Syntax reference</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[dynec(global(
    <span class="comment">// Optional, indicates that the global state is not thread-safe.
    // Forgetting to mark `thread_local` will result in compile error.
    </span>thread_local,
    <span class="comment">// Optional, acknowledges that the entities of the specified archetypes
    // contained in the global state may be uninitialized.
    </span>maybe_uninit(<span class="macro-nonterminal">$ty</span>, <span class="macro-nonterminal">$ty</span>, ...),
))]</span></code></pre></div>
<h3 id="simple-components"><a href="#simple-components">Simple components</a></h3>
<p>Parameters of type <code>ReadSimple&lt;A, C&gt;</code> or <code>WriteSimple&lt;A, C&gt;</code>,
request access to a <a href="../comp/trait.Simple.html" title="trait dynec::comp::Simple">simple component</a> of type <code>C</code>
from entities of the <a href="../archetype/trait.Archetype.html" title="trait dynec::archetype::Archetype">archetype</a> <code>A</code>.
The latter provides mutable and exclusive access to the component storages.</p>
<h4 id="using-other-aliases"><a href="#using-other-aliases">Using other aliases</a></h4>
<p>Using type aliases/renamed imports for the types is also allowed,
but the macro would be unable to infer type parameters and mutability.
In such cases, they must be indicated explicitly in the attribute.
See the syntax reference below for details.</p>
<h4 id="uninitialized-entity-references"><a href="#uninitialized-entity-references">Uninitialized entity references</a></h4>
<p>If <code>C</code> contains <a href="../entity/referrer/trait.Referrer.html" title="trait dynec::entity::referrer::Referrer">references</a> to entities of some archetype <code>T</code>,
the scheduler automatically enforces that the system runs before
any systems that create entities of archetype <code>T</code>,
because components for entities created through <a href="../system/offline_buffer/struct.EntityCreator.html" title="struct dynec::system::offline_buffer::EntityCreator"><code>EntityCreator</code></a>
are uninitialized until the current cycle completes.
Use the <code>maybe_uninit</code> attribute to remove this ordering limitation.</p>
<p>See <a href="../system/partition/struct.EntityCreationPartition.html#component-accessors" title="struct dynec::system::partition::EntityCreationPartition"><code>EntityCreationPartition</code></a>
for more information.</p>
<h4 id="syntax-reference-3"><a href="#syntax-reference-3">Syntax reference</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[dynec(simple(
    <span class="comment">// Optional, specifies the archetype and component explicitly.
    // Only required when the parameter type is not `ReadSimple`/`WriteSimple`.
    </span>arch = <span class="macro-nonterminal">$ty</span>, comp = <span class="macro-nonterminal">$ty</span>,
    <span class="comment">// Optional, indicates that the component access is exclusive explicitly.
    // Only required when the parameter type is not `WriteSimple`.
    </span><span class="kw-2">mut</span>,
    <span class="comment">// Optional, acknowledges that the entities of the specified archetypes
    // contained in the simple components may be uninitialized.
    </span>maybe_uninit(<span class="macro-nonterminal">$ty</span>, <span class="macro-nonterminal">$ty</span>, ...),
))]</span></code></pre></div>
<h3 id="isotope-components"><a href="#isotope-components">Isotope components</a></h3>
<p>Parameters of type <a href="../system/index.html#types" title="mod dynec::system"><code>(Read|Write)Isotope(Full|Partial)</code></a>
request access to an <a href="../comp/trait.Isotope.html" title="trait dynec::comp::Isotope">isotope component</a> of type <code>C</code>
from entities of the <a href="../archetype/trait.Archetype.html" title="trait dynec::archetype::Archetype">archetype</a> <code>A</code>.
The <code>Write</code> variants provide mutable and exclusive access to the component storages.</p>
<h4 id="partial-isotope-access"><a href="#partial-isotope-access">Partial isotope access</a></h4>
<p>If <a href="../system/type.ReadIsotopePartial.html" title="type dynec::system::ReadIsotopePartial"><code>ReadIsotopePartial</code></a> or
<a href="../system/type.WriteIsotopePartial.html" title="type dynec::system::WriteIsotopePartial"><code>WriteIsotopePartial</code></a> is used,
the system only requests access to specific discriminants of the isotope component.
The actual discriminants are specified with an attribute:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[dynec(isotope(discrim = discrim_set))] </span>param_name: <span class="kw">impl </span>ReadIsotope&lt;A, C, K&gt;,</code></pre></div>
<p>The expression <code>discrim_set</code> contains the set of discriminants requested by this system
contained in an implementation of
<code><a href="../comp/discrim/trait.Set.html" title="trait dynec::comp::discrim::Set">discrim::Set</a>&lt;C::<a href="../comp/discrim/trait.Discrim.html" title="trait dynec::comp::discrim::Discrim">Discrim</a>&gt;</code>,
which is typically an array or a <a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec"><code>Vec</code></a>.
The expression may reference param states directly.
The expression is only evaluated once before the first run of the system,
so it will not react to subsequent changes to the param states.</p>
<p><code>K</code> is the type of the <a href="../comp/discrim/trait.Set.html#associatedtype.Key" title="associated type dynec::comp::discrim::Set::Key">key</a> to index the discriminant set.</p>
<p>See the documentation of <a href="../comp/discrim/trait.Set.html" title="trait dynec::comp::discrim::Set"><code>discrim::Set</code></a> for more information.</p>
<h4 id="using-other-aliases-1"><a href="#using-other-aliases-1">Using other aliases</a></h4>
<p>Using type aliases/renamed imports for the types is also allowed,
but the macro would be unable to infer type parameters and mutability.
In such cases, they must be indicated explicitly in the attribute.
See the syntax reference below for details.</p>
<h4 id="uninitialized-entity-references-1"><a href="#uninitialized-entity-references-1">Uninitialized entity references</a></h4>
<p>If <code>C</code> contains <a href="../entity/referrer/trait.Referrer.html" title="trait dynec::entity::referrer::Referrer">references</a> to entities of some archetype <code>T</code>,
the scheduler automatically enforces that the system runs before
any systems that create entities of archetype <code>T</code>,
because components for entities created through <a href="../system/offline_buffer/struct.EntityCreator.html" title="struct dynec::system::offline_buffer::EntityCreator"><code>EntityCreator</code></a>
are uninitialized until the current cycle completes.
Use the <code>maybe_uninit</code> attribute to remove this ordering limitation.</p>
<p>See <a href="../system/partition/struct.EntityCreationPartition.html#component-accessors" title="struct dynec::system::partition::EntityCreationPartition"><code>EntityCreationPartition</code></a>
for more information.</p>
<h4 id="syntax-reference-4"><a href="#syntax-reference-4">Syntax reference</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[dynec(isotope(
    <span class="comment">// Required if and only if the type is ReadIsotopePartial or WriteIsotopePartial.
    </span>discrim = <span class="macro-nonterminal">$expr</span>,
    <span class="comment">// Optional, must be the same as the type of the `discrim` expression.
    // Only required when the parameter type is not `ReadIsotopePartial`/`WriteIsotopePartial`.
    // Note that `ReadIsotopePartial`/`WriteIsotopePartial` have an optional third type parameter
    // that expects the same type as `discrim_set`,
    // which is `Vec&lt;C::Discrim&gt;` by default.
    </span>discrim_set = <span class="macro-nonterminal">$ty</span>,
    <span class="comment">// Optional, specifies the archetype and component explicitly.
    // Only required when the parameter type is not `(Read|Write)Isotope(Full|Partial)`.
    </span>arch = <span class="macro-nonterminal">$ty</span>, comp = <span class="macro-nonterminal">$ty</span>,
    <span class="comment">// Optional, indicates that the component access is exclusive explicitly.
    // Only required when the parameter type is not `impl WriteSimple`.
    </span><span class="kw-2">mut</span>,
    <span class="comment">// Optional, acknowledges that the entities of the specified archetypes
    // contained in the simple components may be uninitialized.
    </span>maybe_uninit(<span class="macro-nonterminal">$ty</span>, <span class="macro-nonterminal">$ty</span>, ...),
))]</span></code></pre></div>
<h3 id="entity-creation"><a href="#entity-creation">Entity creation</a></h3>
<p>Parameters that require an <a href="../system/offline_buffer/struct.EntityCreator.html" title="struct dynec::system::offline_buffer::EntityCreator"><code>EntityCreator</code></a>
can be used to create entities.
The archetype of created entities is specified in the type bounds.
Note that entity creation is asynchronous to ensure synchronization,
i.e. components of the created entity are deferred until the current cycle completes.</p>
<p>Systems that create entities of an archetype <code>A</code> should be scheduled to execute
after all systems that may read entity references of archetype <code>A</code>
(through strong or weak references stored in
local states, global states, simple components or isotope components).
See <a href="../system/partition/struct.EntityCreationPartition.html#entity-creators" title="struct dynec::system::partition::EntityCreationPartition"><code>EntityCreationPartition</code></a>
for more information.</p>
<p>If it can be ensured that the new uninitialized entities cannot be leaked to other systems,
e.g. if the created entity ID is not stored into any states,
the attribute <code>#[dynec(entity_creator(no_partition))]</code>
can be applied on the entity-creating parameter
to avoid registering the automatic dependency to run after <code>EntityCreationPartition&lt;A&gt;</code>.</p>
<h4 id="syntax-reference-5"><a href="#syntax-reference-5">Syntax reference</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// This attribute is not required unless `EntityCreator` is aliased.
</span><span class="attr">#[dynec(entity_creator(
    <span class="comment">// Optional, specifies the archetype if `EntityCreator` is aliased.
    </span>arch = <span class="macro-nonterminal">$ty</span>,
    <span class="comment">// Optional, allows the derived system to execute before
    // the EntityCreationPartition of this archetype.
    </span>no_partition,
))]</span></code></pre></div>
<h3 id="entity-deletion"><a href="#entity-deletion">Entity deletion</a></h3>
<p>Parameters that require an <a href="../system/offline_buffer/struct.EntityDeleter.html" title="struct dynec::system::offline_buffer::EntityDeleter"><code>EntityDeleter</code></a>
can be used to delete entities.
The archetype of deleted entities is specified in the type bounds.
Note that <code>EntityDeleter</code> can only be used to mark entities as “deleting”;
the entity is only deleted after
all <a href="../comp/trait.Simple.html#associatedconstant.IS_FINALIZER" title="associated constant dynec::comp::Simple::IS_FINALIZER">finalizer</a> components are unset.</p>
<p>It is advisable to execute finalizer-removing systems
after systems that mark entities for deletion finish executing.
This allows deletion to happen in the same cycle,
thus slightly reducing entity deletion latency
(but this is not supposed to be critical anyway).
Nevertheless, unlike entity creation,
the scheduler does not automatically enforce ordering between
finalizer-manipulating systems and entity-deleting systems.</p>
<h4 id="syntax-reference-6"><a href="#syntax-reference-6">Syntax reference</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// This attribute is not required unless `EntityDeleter` is aliased.
</span><span class="attr">#[dynec(entity_deleter(
    <span class="comment">// Optional, specifies the archetype if `EntityDeleter` is aliased.
    </span>arch = <span class="macro-nonterminal">$ty</span>,
))]</span></code></pre></div>
<h3 id="entity-iterator"><a href="#entity-iterator">Entity iterator</a></h3>
<p>Parameters that require an <a href="../system/iter/struct.EntityIterator.html" title="struct dynec::system::iter::EntityIterator"><code>EntityIterator</code></a>
can be used to iterate over entities and zip multiple component iterators.
See the documentation for <code>EntityIterator</code> for details.</p>
<h4 id="syntax-reference-7"><a href="#syntax-reference-7">Syntax reference</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// This attribute is not required unless `EntityIterator` is aliased.
</span><span class="attr">#[dynec(entity_iterator(
    <span class="comment">// Optional, specifies the archetype if `EntityIterator` is aliased.
    </span>arch = <span class="macro-nonterminal">$ty</span>,
))]</span></code></pre></div>
<h2 id="example"><a href="#example">Example</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>dynec::system;

<span class="attr">#[dynec::global(initial = Title(<span class="string">&quot;hello world&quot;</span>))]
</span><span class="kw">struct </span>Title(<span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>str);

<span class="attr">#[derive(Debug, PartialEq, Eq, Hash)]
</span><span class="kw">struct </span>Foo;

<span class="macro">dynec::archetype!</span>(Player);

<span class="attr">#[dynec::comp(of = Player)]
</span><span class="kw">struct </span>PositionX(f32);
<span class="attr">#[dynec::comp(of = Player)]
</span><span class="kw">struct </span>PositionY(f32);

<span class="attr">#[dynec::comp(of = Player)]
</span><span class="kw">struct </span>Direction(f32, f32);

<span class="attr">#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, dynec::Discrim)]
</span><span class="kw">struct </span>SkillType(usize);

<span class="attr">#[dynec::comp(of = Player, isotope = SkillType)]
</span><span class="kw">struct </span>SkillLevel(u8);

<span class="attr">#[system(
    name = <span class="macro">format!</span>(<span class="string">&quot;simulate[counter = {}, skill_id = {:?}]&quot;</span>, counter, skill_id),
    before(Foo),
)]
</span><span class="kw">fn </span>simulate(
    <span class="attr">#[dynec(local(initial = <span class="number">0</span>))] </span>counter: <span class="kw-2">&amp;mut </span>u16,
    <span class="attr">#[dynec(param)] </span><span class="kw-2">&amp;</span>skill_id: <span class="kw-2">&amp;</span>SkillType,
    <span class="attr">#[dynec(global)] </span>title: <span class="kw-2">&amp;mut </span>Title,
    x: system::WriteSimple&lt;Player, PositionX&gt;,
    y: system::WriteSimple&lt;Player, PositionY&gt;,
    dir: system::ReadSimple&lt;Player, Direction&gt;,
    <span class="attr">#[dynec(isotope(discrim = [skill_id]</span>))] skill: system::ReadIsotopePartial&lt;
        Player,
        SkillLevel,
        [SkillType; <span class="number">1</span>],
    &gt;,
) {
    <span class="kw-2">*</span>counter += <span class="number">1</span>;

    <span class="kw">if </span><span class="kw-2">*</span>counter == <span class="number">1 </span>{
        title.<span class="number">0 </span>= <span class="string">&quot;changed&quot;</span>;
    }
}

<span class="kw">let </span>system = simulate.build(SkillType(<span class="number">3</span>));
<span class="macro">assert_eq!</span>(
    system::Descriptor::get_spec(<span class="kw-2">&amp;</span>system).debug_name.as_str(),
    <span class="string">&quot;simulate[counter = 0, skill_id = SkillType(3)]&quot;
</span>);

{
    <span class="comment">// We can also call the function directly in unit tests.

    </span><span class="kw">let </span><span class="kw-2">mut </span>counter = <span class="number">0</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>title = Title(<span class="string">&quot;original&quot;</span>);

    <span class="kw">let </span><span class="kw-2">mut </span>world = <span class="macro">dynec::system_test! </span>{
        simulate.build(SkillType(<span class="number">2</span>));
        <span class="kw">_</span>: Player = (
            PositionX(<span class="number">0.0</span>),
            PositionY(<span class="number">0.0</span>),
            Direction(<span class="number">0.5</span>, <span class="number">0.5</span>),
        );
        <span class="kw">_</span>: Player = (
            PositionX(<span class="number">0.5</span>),
            PositionY(<span class="number">0.5</span>),
            Direction(<span class="number">0.5</span>, <span class="number">0.5</span>),
        );
    };

    simulate::call(
        <span class="kw-2">&amp;mut </span>counter,
        <span class="kw-2">&amp;</span>SkillType(<span class="number">2</span>),
        <span class="kw-2">&amp;mut </span>title,
        world.components.write_simple_storage(),
        world.components.write_simple_storage(),
        world.components.read_simple_storage(),
        world.components.read_partial_isotope_storage(
            <span class="kw-2">&amp;</span>[SkillType(<span class="number">3</span>)],
            world.ealloc_map.snapshot::&lt;Player&gt;(),
        ),
    );

    <span class="macro">assert_eq!</span>(counter, <span class="number">1</span>);
    <span class="macro">assert_eq!</span>(title.<span class="number">0</span>, <span class="string">&quot;changed&quot;</span>);
}</code></pre></div>
</div></details></section></div></main></body></html>