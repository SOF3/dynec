use std::cell::RefCell;
use std::marker::PhantomData;
use std::mem;

use super::access;
use crate::entity::{self, ealloc, Raw as _};
use crate::world::offline;
use crate::{comp, Archetype};

/// Allows creating entities of an archetype.
pub struct EntityCreator<'t, A: Archetype> {
    buffer: &'t RefCell<&'t mut offline::BufferShard>,
    ealloc: ealloc::BorrowedShard<'t, A>,
}

impl<'t, A: Archetype> EntityCreator<'t, A> {
    /// Constructs an entity creator.
    pub fn new(
        buffer: &'t RefCell<&'t mut offline::BufferShard>,
        ealloc: ealloc::BorrowedShard<'t, A>,
    ) -> Self {
        Self { buffer, ealloc }
    }

    /// Queues to create an entity.
    pub fn create(&mut self, comps: comp::Map<A>) -> entity::Entity<A> {
        self.with_hint(comps, Default::default())
    }

    /// Queues to create an entity with hint.
    pub fn with_hint(
        &mut self,
        comps: comp::Map<A>,
        hint: <A::Ealloc as entity::Ealloc>::AllocHint,
    ) -> entity::Entity<A> {
        let mut buffer = self.buffer.borrow_mut();
        let ealloc = &mut *self.ealloc;
        buffer.create_entity_with_hint_and_shard(comps, &mut *ealloc, hint)
    }
}

/// Allows deleting entities of an archetype.
#[doc(hidden)]
pub struct EntityDeleter<'t, A: Archetype> {
    buffer: &'t RefCell<&'t mut offline::BufferShard>,
    _ph:    PhantomData<A>,
}

impl<'t, A: Archetype> EntityDeleter<'t, A> {
    /// Constructs an entity deleter from a macro.
    pub fn new(buffer: &'t RefCell<&'t mut offline::BufferShard>) -> Self {
        Self { buffer, _ph: PhantomData }
    }

    /// Queues to mark an entity for deletion.
    pub fn queue<E: entity::Ref<Archetype = A>>(&mut self, entity: E) {
        let mut buffer = self.buffer.borrow_mut();
        buffer.delete_entity::<A, E>(entity);
    }
}

pub struct EntityIterator<A: Archetype> {
    ealloc: ealloc::Snapshot<A::RawEntity>,
}

impl<A: Archetype> EntityIterator<A> {
    /// Constructs an instance of [`EntityIterator`] that reads from the given allocator.
    ///
    /// Although this function accepts an allocator shard,
    /// it actually reads the global buffer shared between shards,
    /// which is independent of the changes in the current shard.
    /// Hence, the iterator describe the state after the previous tick completes,
    /// which does not include newly initialized entities
    /// and includes those queued for deletion.
    /// This behavior is reasonable, because newly initialized entities should not be accessed at all,
    /// and those queued for deletion may have a finalizer or
    /// be given a finalizer when running later systems,
    /// so those queued for deletion are still included.
    ///
    /// This function is typically called from the code generated by
    /// [`#[system]`](macro@crate::system).
    pub fn new(ealloc: ealloc::Snapshot<A::RawEntity>) -> Self { Self { ealloc } }

    /// Iterates over all entity IDs in this archetype.
    pub fn entities(&self) -> impl Iterator<Item = entity::TempRef<A>> {
        self.ealloc
            .iter_allocated_chunks()
            .flat_map(<A::RawEntity as entity::Raw>::range)
            .map(entity::TempRef::new)
    }

    /// Iterates over all contiguous chunks of entity IDs.
    pub fn chunks(&self) -> impl Iterator<Item = entity::TempRefChunk<A>> + '_ {
        self.ealloc
            .iter_allocated_chunks()
            .map(|range| entity::TempRefChunk::new(range.start, range.end))
    }

    /// Iterates over all entities, yielding the components requested.
    pub fn entities_with<IntoZ: access::IntoZip<Archetype = A>>(
        &self,
        zip: IntoZ,
    ) -> impl Iterator<Item = (entity::TempRef<A>, <IntoZ::IntoZip as access::Zip>::Item)> {
        let mut zip = ZipIter(zip.into_zip());
        self.ealloc
            .iter_allocated_chunks()
            .flat_map(<A::RawEntity as entity::Raw>::range)
            .map(move |entity| (entity::TempRef::new(entity), zip.take_serial(entity)))
    }

    /// Iterates over all entities, yielding the components requested in contiguous chunks.
    pub fn chunks_with<IntoZ: access::IntoZip<Archetype = A>>(
        &self,
        zip: IntoZ,
    ) -> impl Iterator<Item = (entity::TempRefChunk<A>, <IntoZ::IntoZip as access::ZipChunked>::Chunk)>
    where
        IntoZ::IntoZip: access::ZipChunked,
    {
        let mut zip = ZipIter(zip.into_zip());
        self.ealloc.iter_allocated_chunks().map(move |chunk| {
            (
                entity::TempRefChunk::new(chunk.start, chunk.end),
                zip.take_serial_chunk(chunk.start, chunk.end),
            )
        })
    }
}

struct ZipIter<Z: access::Zip>(Z);

impl<Z: access::Zip> ZipIter<Z> {
    fn take_serial(&mut self, entity: <Z::Archetype as Archetype>::RawEntity) -> Z::Item {
        let right = self.0.split(entity.add(1));
        let left = mem::replace(&mut self.0, right);
        left.get(entity::TempRef::new(entity))
    }
}

impl<Z: access::ZipChunked> ZipIter<Z> {
    fn take_serial_chunk(
        &mut self,
        start: <Z::Archetype as Archetype>::RawEntity,
        end: <Z::Archetype as Archetype>::RawEntity,
    ) -> Z::Chunk {
        let right = self.0.split(end.add(1));
        let left = mem::replace(&mut self.0, right);
        left.get_chunk(entity::TempRefChunk::new(start, end))
    }
}
