use std::cell::RefCell;
use std::marker::PhantomData;

use crate::entity::{self, ealloc};
use crate::world::offline;
use crate::{comp, Archetype};

/// Allows creating entities of an archetype.
pub struct EntityCreator<'t, A: Archetype> {
    buffer: &'t RefCell<&'t mut offline::BufferShard>,
    ealloc: ealloc::BorrowedShard<'t, A>,
}

impl<'t, A: Archetype> EntityCreator<'t, A> {
    /// Constructs an entity creator.
    pub fn new(
        buffer: &'t RefCell<&'t mut offline::BufferShard>,
        ealloc: ealloc::BorrowedShard<'t, A>,
    ) -> Self {
        Self { buffer, ealloc }
    }

    /// Queues to create an entity.
    pub fn create(&mut self, comps: comp::Map<A>) -> entity::Entity<A> {
        self.with_hint(comps, Default::default())
    }

    /// Queues to create an entity with hint.
    pub fn with_hint(
        &mut self,
        comps: comp::Map<A>,
        hint: <A::Ealloc as entity::Ealloc>::AllocHint,
    ) -> entity::Entity<A> {
        let mut buffer = self.buffer.borrow_mut();
        let ealloc = &mut *self.ealloc;
        buffer.create_entity_with_hint_and_shard(comps, &mut *ealloc, hint)
    }
}

/// Allows deleting entities of an archetype.
#[doc(hidden)]
pub struct EntityDeleter<'t, A: Archetype> {
    buffer: &'t RefCell<&'t mut offline::BufferShard>,
    _ph:    PhantomData<A>,
}

impl<'t, A: Archetype> EntityDeleter<'t, A> {
    /// Constructs an entity deleter from a macro.
    pub fn new(buffer: &'t RefCell<&'t mut offline::BufferShard>) -> Self {
        Self { buffer, _ph: PhantomData }
    }

    /// Queues to mark an entity for deletion.
    pub fn queue<E: entity::Ref<Archetype = A>>(&mut self, entity: E) {
        let mut buffer = self.buffer.borrow_mut();
        buffer.delete_entity::<A, E>(entity);
    }
}

pub struct EntityIterator<A: Archetype> {
    ealloc: ealloc::Snapshot<A::RawEntity>,
}

impl<A: Archetype> EntityIterator<A> {
    /// Constructs an instance of [`EntityIterator`] that reads from the given allocator.
    ///
    /// Although this function accepts an allocator shard,
    /// it actually reads the global buffer shared between shards,
    /// which is independent of the changes in the current shard.
    /// Hence, the iterator describe the state after the previous tick completes,
    /// which does not include newly initialized entities
    /// and includes those queued for deletion.
    /// This behavior is reasonable, because newly initialized entities should not be accessed at all,
    /// and those queued for deletion may have a finalizer or
    /// be given a finalizer when running later systems,
    /// so those queued for deletion are still included.
    ///
    /// This function is typically called from the code generated by
    /// [`#[system]`](macro@crate::system).
    pub fn new(ealloc: ealloc::Snapshot<A::RawEntity>) -> Self { Self { ealloc } }

    pub fn entities(&self) -> impl Iterator<Item = entity::TempRef<A>> {
        self.ealloc
            .iter_allocated_chunks()
            .flat_map(<A::RawEntity as entity::Raw>::range)
            .map(entity::TempRef::new)
    }

    fn chunks(&self) -> impl Iterator<Item = entity::TempRefChunk<A>> + '_ {
        self.ealloc
            .iter_allocated_chunks()
            .map(|range| entity::TempRefChunk::new(range.start, range.end))
    }

    // TODO add entities_with(Tuple<system::Access>)
}
