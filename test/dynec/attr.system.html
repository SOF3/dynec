<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Converts a function into a system."><meta name="keywords" content="rust, rustlang, rust-lang, system"><title>system in dynec - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-1d803bfaeffdc91e.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-1a026a992ced2f86.css"><link rel="stylesheet" disabled href="../static.files/dark-c1fb1a2e91ddd376.css"><link rel="stylesheet" disabled href="../static.files/ayu-0d555a04945d1455.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-458bffc4c06ccf37.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc attr"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../dynec/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../dynec/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><div class="sidebar-elems"><h2><a href="index.html">In dynec</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Attribute Macro <a href="index.html">dynec</a>::<wbr><a class="attr" href="#">system</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/dynec_codegen/lib.rs.html#53">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><div class="item-decl"><pre class="rust attr"><code>#[system]</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Converts a function into a system.</p>
<p>This macro converts the function into a unit struct with the same name
that implements <a href="system/struct.Spec.html"><code>system::Spec</code></a>.
The unit struct also derefs to a function pointer,
so it is still possible to call the function directly (mainly useful in unit tests)
without any change in the signature.
However it is not recommended to call this function directly in production code.</p>
<h2 id="options"><a href="#options">Options</a></h2>
<p>Options are applied behind the attribute name in the form <code>#[system(...)]</code>.
Multiple options are separated by commas.</p>
<h3 id="name--expr"><a href="#name--expr"><code>name = $expr</code></a></h3>
<p>Sets the <a href="system/struct.Spec.html#structfield.debug_name">name</a> of the system to <code>$expr</code>.
By default, the name is <code>concat!(module_path!(), &quot;::&quot;, $function_identifier)</code>.</p>
<p>The <code>$expr</code> can read the local and param states of the system directly.
Since the debug name is only used for display purposes,
it is allowed (although confusing to the programmer) to use mutable states in the name.
It is unspecified whether debug messages use the initial debug name or the updated state.</p>
<h3 id="beforeexpr1-expr2--and-afterexpr1-expr2-"><a href="#beforeexpr1-expr2--and-afterexpr1-expr2-"><code>before($expr1, $expr2, ...)</code> and <code>after($expr1, $expr2, ...)</code></a></h3>
<p>Indicates that the system must be executed
before/after all <a href="system/partition/trait.Partition.html">partitions</a> given in the expressions.</p>
<p>Similar to <code>name</code>, the expressions can read local and param states directly.
However, only the expressions are only resolved once before the first run of the system,
so mutating states has no effect on the system schedule.</p>
<h2 id="parameters"><a href="#parameters">Parameters</a></h2>
<p>Each parameter of a system function has a special meaning:</p>
<h3 id="local-states"><a href="#local-states">Local states</a></h3>
<p>Parameters with the attribute <code>#[dynec(local(initial = xxx))]</code> are “local states”,
where <code>xxx</code> is an expression that evaluates to the initial value of the state.</p>
<p>Local states must take the type <code>&amp;T</code> or <code>&amp;mut T</code>,
where <code>T</code> is the actual stored state.
The mutated state persists for each instance of the system.</p>
<p>Use global states instead if the local state needs to be accessed from multiple systems.</p>
<p>Since entity references can be stored in local states,
the struct used to store local states also implements
<a href="entity/referrer/trait.Referrer.html"><code>entity::Referrer</code></a>.
The corresponding <code>entity</code> and <code>not_entity</code> attributes can be inside the <code>local()</code> instead.</p>
<p>Unlike global states, local states do not need to specify thread safety.
Thread safety of local states is checked at compile time
when the system is passed to the scheduler.</p>
<h4 id="syntax-reference"><a href="#syntax-reference">Syntax reference</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[dynec(local(
    <span class="comment">// Required, the initial value of the local state.
    </span>initial = <span class="macro-nonterminal">$expr</span>,
    <span class="comment">// Optional, equivalent to #[entity] in #[derive(EntityRef)].
    </span>entity,
    <span class="comment">// Optional, equivalent to #[not_entity] in #[derive(EntityRef)].
    </span>not_entity,
))]</span></code></pre></div>
<h3 id="param-states"><a href="#param-states">Param states</a></h3>
<p>Parameters with the attribute <code>#[dynec(param)]</code> are “param states”.
The user has to pass initial values for param states in the <code>.build()</code> method.
Param states behave identically to local states
except for different definition location of the initial value.</p>
<p>It is typically used to initialize systems with resources that cannot be created statically
(e.g. system canvas resources),
or to schedule multiple systems declared from the same function
(e.g. working on multiple discriminants of an isotope component).</p>
<p>Similar to local states, param states can also use <code>entity</code> and <code>not_entity</code>.</p>
<h4 id="syntax-reference-1"><a href="#syntax-reference-1">Syntax reference</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[dynec(param(
    <span class="comment">// Optional, equivalent to #[entity] in #[derive(EntityRef)].
    </span>entity,
    <span class="comment">// Optional, equivalent to #[not_entity] in #[derive(EntityRef)].
    </span>not_entity,
))]</span></code></pre></div>
<h3 id="global-states"><a href="#global-states">Global states</a></h3>
<p>Parameters with the attribute <code>#[dynec(global)]</code> are “global states”.
Global states are shared scalar data between multiple systems.
See <a href="trait.Global.html"><code>Global</code></a> for more information.</p>
<p>Thread-unsafe (non-<code>Send + Sync</code>) global states must be declared as
<code>#[dynec(global(thread_local))]</code> to indicate that
the global state can only be accessed from the main thread.
As a result, systems that request thread-local global states
will only be scheduled on the main thread.</p>
<h4 id="syntax-reference-2"><a href="#syntax-reference-2">Syntax reference</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[dynec(global(
    <span class="comment">// Optional, indicates that the global state is not thread-safe.
    // Forgetting to mark `thread_local` will result in compile error.
    </span>thread_local,
    <span class="comment">// Optional, acknowledges that the entities of the specified archetypes
    // contained in the global state may be uninitialized.
    </span>maybe_uninit(<span class="macro-nonterminal">$ty</span>, <span class="macro-nonterminal">$ty</span>, ...),
))]</span></code></pre></div>
<h3 id="simple-components"><a href="#simple-components">Simple components</a></h3>
<p>Parameters in the form <code>impl ReadSimple&lt;A, C&gt;</code> or <code>impl WriteSimple&lt;A, C&gt;</code>,
request access to a <a href="comp/trait.Simple.html">simple component</a> of type <code>C</code>
from entities of the <a href="archetype/trait.Archetype.html">archetype</a> <code>A</code>,
exposed through a type that implements <a href="system/trait.ReadSimple.html"><code>system::ReadSimple</code></a>
or <a href="system/trait.WriteSimple.html"><code>system::WriteSimple</code></a>.
The latter provides mutable and exclusive access to the component storages.</p>
<h4 id="using-other-bounds"><a href="#using-other-bounds">Using other bounds</a></h4>
<p>Other trait bounds for the parameter are also allowed,
but the macro would not be able to infer type parameters and mutability.
In such cases, they must be indicated explicitly in the attribute.
See the syntax reference below for details.</p>
<h4 id="uninitialized-entity-references"><a href="#uninitialized-entity-references">Uninitialized entity references.</a></h4>
<p>Entity creation ordering is automatically enforced if <code>C</code> contains entity references,
Use the <code>maybe_uninit</code> attribute to remove this ordering.</p>
<p>See <a href="system/partition/struct.EntityCreationPartition.html#component-accessors"><code>EntityCreationPartition</code></a>
for more information.</p>
<h4 id="syntax-reference-3"><a href="#syntax-reference-3">Syntax reference</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[dynec(simple(
    <span class="comment">// Optional, specifies the archetype and component explicitly.
    // Only required when the parameter type is not `impl ReadSimple`/`impl WriteSimple`.
    </span>arch = <span class="macro-nonterminal">$ty</span>, comp = <span class="macro-nonterminal">$ty</span>,
    <span class="comment">// Optional, indicates that the component access is exclusive explicitly.
    // Only required when the parameter type is not `impl WriteSimple`.
    </span><span class="kw-2">mut</span>,
    <span class="comment">// Optional, acknowledges that the entities of the specified archetypes
    // contained in the simple components may be uninitialized.
    </span>maybe_uninit(<span class="macro-nonterminal">$ty</span>, <span class="macro-nonterminal">$ty</span>, ...),
))]</span></code></pre></div>
<h3 id="isotope-components"><a href="#isotope-components">Isotope components</a></h3>
<p>Parameters in the form <code>impl ReadIsotope&lt;A, C&gt;</code> or <code>impl WriteIsotope&lt;A, C&gt;</code>,
request access to an <a href="comp/trait.Isotope.html">isotope component</a> of type <code>C</code>
from entities of the <a href="archetype/trait.Archetype.html">archetype</a> <code>A</code>,
exposed through a type that implements <a href="system/trait.ReadIsotope.html"><code>system::ReadIsotope</code></a>
or <a href="system/trait.WriteIsotope.html"><code>system::WriteIsotope</code></a>.
The latter provides mutable and exclusive access to the component storages.</p>
<h4 id="partial-isotope-access"><a href="#partial-isotope-access">Partial isotope access</a></h4>
<p>By default, all discriminants of the isotope component are requested,
such that writes are exclusive with all systems that read any part of the discriminants.
The accessor can be made partial instead:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[dynec(isotope(discrim = discrim_set))] </span>param_name: <span class="kw">impl </span>ReadIsotope&lt;A, C, K&gt;,</code></pre></div>
<p>The expression <code>discrim_set</code> implements
<code><a href="comp/discrim/trait.Set.html">discrim::Set</a>&lt;C::<a href="comp/discrim/trait.Discrim.html">Discrim</a>&gt;</code>,
which is the set of discriminants that this system uses.
The expression can reference local and param states directly.
However, since it is only evaluated once before the first run of the system,
subsequent writes to the states have no effect on the resolved discriminant set.</p>
<p><code>K</code> is the type of the <a href="comp/discrim/trait.Set.html#associatedtype.Key">key</a> to index the discriminant set.</p>
<p>See the documentation of <a href="comp/discrim/trait.Set.html"><code>discrim::Set</code></a> for more information.</p>
<h4 id="using-other-bounds-1"><a href="#using-other-bounds-1">Using other bounds</a></h4>
<p>Other trait bounds for the parameter are also allowed,
but the macro would not be able to infer type parameters and mutability.
In such cases, they must be indicated explicitly in the attribute.
See the syntax reference below for details.</p>
<h4 id="uninitialized-entity-references-1"><a href="#uninitialized-entity-references-1">Uninitialized entity references.</a></h4>
<p>Entity creation ordering is automatically enforced if <code>C</code> contains entity references,
Use the <code>maybe_uninit</code> attribute to remove this ordering.</p>
<p>See <a href="system/partition/struct.EntityCreationPartition.html#component-accessors"><code>EntityCreationPartition</code></a>
for more information.</p>
<h4 id="syntax-reference-4"><a href="#syntax-reference-4">Syntax reference</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[dynec(isotope(
    <span class="comment">// Optional, indicates that this accessor only uses the given subset of discriminants.
    </span>discrim = <span class="macro-nonterminal">$expr</span>,
    <span class="comment">// Optional, must be the same as the `Key` associated type of the `discrim` expression.
    // Only required when the parameter type is not `impl ReadIsotope`/`impl WriteIsotope`.
    </span>discrim_key = <span class="macro-nonterminal">$ty</span>,
    <span class="comment">// Optional, specifies the archetype and component explicitly.
    // Only required when the parameter type is not `impl ReadIsotope`/`impl WriteIsotope`.
    </span>arch = <span class="macro-nonterminal">$ty</span>, comp = <span class="macro-nonterminal">$ty</span>,
    <span class="comment">// Optional, indicates that the component access is exclusive explicitly.
    // Only required when the parameter type is not `impl WriteSimple`.
    </span><span class="kw-2">mut</span>,
    <span class="comment">// Optional, acknowledges that the entities of the specified archetypes
    // contained in the simple components may be uninitialized.
    </span>maybe_uninit(<span class="macro-nonterminal">$ty</span>, <span class="macro-nonterminal">$ty</span>, ...),
))]</span></code></pre></div>
<h3 id="entity-creation"><a href="#entity-creation">Entity creation</a></h3>
<p>Parameters that require an implementation of <a href="system/trait.EntityCreator.html"><code>EntityCreator</code></a>
can be used to create entities.
The archetype of created entities is specified in the type bounds.
Note that entity creation is asynchronous to ensure synchronization,
i.e. components of the created entity are deferred until the current cycle completes.</p>
<p>Systems that create entities of an archetype <code>A</code> should be scheduled to execute
after all systems that may read entity references of archetype <code>A</code>
(through strong or weak references stored in
local states, global states, simple components or isotope components).
See <a href="system/partition/struct.EntityCreationPartition.html#entity-creators"><code>EntityCreationPartition</code></a>
for more information.</p>
<p>If it can be ensured that the new uninitialized entities cannot be leaked to other systems,
e.g. if the created entity ID is not stored into any states,
the attribute <code>#[dynec(entity_creator(no_partition))]</code>
can be applied on the entity-creating parameter
to avoid registering the automatic dependency to run after <code>EntityCreationPartition&lt;A&gt;</code>.</p>
<h4 id="syntax-reference-5"><a href="#syntax-reference-5">Syntax reference</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// This attribute is not required unless `EntityCreator` is aliased.
</span><span class="attr">#[dynec(entity_creator(
    <span class="comment">// Optional, specifies the archetype if `EntityCreator` is aliased.
    </span>arch = <span class="macro-nonterminal">$ty</span>,
    <span class="comment">// Optional, allows the derived system to execute before
    // the EntityCreationPartition of this archetype.
    </span>no_partition,
))]</span></code></pre></div>
<h3 id="entity-deletion"><a href="#entity-deletion">Entity deletion</a></h3>
<p>Parameters that require an implementation of <a href="system/trait.EntityDeleter.html"><code>EntityDeleter</code></a>
can be used to delete entities.
The archetype of deleted entities is specified in the type bounds.
Note that <code>EntityDeleter</code> can only be used to mark entities as “deleting”;
the entity is only deleted after
all <a href="comp/trait.Simple.html#associatedconstant.IS_FINALIZER">finalizer</a> components are unset.</p>
<p>It is advisable to execute finalizer-removing systems
after systems that mark entities for deletion finish executing.
This allows deletion to happen in the same cycle,
thus slightly improving entity deletion performance
(but this is not supposed to be critical anyway).
Nevertheless, unlike entity creation, entity deletion does not have an automatic partition.</p>
<h4 id="syntax-reference-6"><a href="#syntax-reference-6">Syntax reference</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// This attribute is not required unless `EntityDeleter` is aliased.
</span><span class="attr">#[dynec(entity_deleter(
    <span class="comment">// Optional, specifies the archetype if `EntityDeleter` is aliased.
    </span>arch = <span class="macro-nonterminal">$ty</span>,
))]</span></code></pre></div>
<h2 id="example"><a href="#example">Example</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>dynec::system;

<span class="attr">#[dynec::global(initial = Title(<span class="string">&quot;hello world&quot;</span>))]
</span><span class="kw">struct </span>Title(<span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>str);

<span class="attr">#[derive(Debug, PartialEq, Eq, Hash)]
</span><span class="kw">struct </span>Foo;

<span class="macro">dynec::archetype!</span>(Player);

<span class="attr">#[dynec::comp(of = Player)]
</span><span class="kw">struct </span>PositionX(f32);
<span class="attr">#[dynec::comp(of = Player)]
</span><span class="kw">struct </span>PositionY(f32);

<span class="attr">#[dynec::comp(of = Player)]
</span><span class="kw">struct </span>Direction(f32, f32);

<span class="attr">#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, dynec::Discrim)]
</span><span class="kw">struct </span>SkillType(usize);

<span class="attr">#[dynec::comp(of = Player, isotope = SkillType, init = || [(SkillType(<span class="number">0</span>), SkillLevel(<span class="number">1</span>))]</span>)]
<span class="kw">struct </span>SkillLevel(u8);

<span class="attr">#[system(
    name = <span class="macro">format!</span>(<span class="string">&quot;simulate[counter = {}, skill_id = {:?}]&quot;</span>, counter, skill_id),
    before(Foo),
)]
</span><span class="kw">fn </span>simulate(
    <span class="attr">#[dynec(local(initial = <span class="number">0</span>))] </span>counter: <span class="kw-2">&amp;mut </span>u16,
    <span class="attr">#[dynec(param)] </span><span class="kw-2">&amp;</span>skill_id: <span class="kw-2">&amp;</span>SkillType,
    <span class="attr">#[dynec(global)] </span>title: <span class="kw-2">&amp;mut </span>Title,
    x: <span class="kw">impl </span>system::WriteSimple&lt;Player, PositionX&gt;,
    y: <span class="kw">impl </span>system::WriteSimple&lt;Player, PositionY&gt;,
    dir: <span class="kw">impl </span>system::ReadSimple&lt;Player, Direction&gt;,
    <span class="attr">#[dynec(isotope(discrim = [skill_id]</span>))] skill: <span class="kw">impl </span>system::ReadIsotope&lt;
        Player,
        SkillLevel,
        usize,
    &gt;,
) {
    <span class="kw-2">*</span>counter += <span class="number">1</span>;

    <span class="kw">if </span><span class="kw-2">*</span>counter == <span class="number">1 </span>{
        title.<span class="number">0 </span>= <span class="string">&quot;changed&quot;</span>;
    }
}

<span class="kw">let </span>system = simulate.build(SkillType(<span class="number">3</span>));
<span class="macro">assert_eq!</span>(
    system::Descriptor::get_spec(<span class="kw-2">&amp;</span>system).debug_name.as_str(),
    <span class="string">&quot;simulate[counter = 0, skill_id = SkillType(3)]&quot;
</span>);

{
    <span class="comment">// We can also call the function directly in unit tests.

    </span><span class="kw">let </span><span class="kw-2">mut </span>counter = <span class="number">0</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>title = Title(<span class="string">&quot;original&quot;</span>);

    <span class="kw">let </span><span class="kw-2">mut </span>world = <span class="macro">dynec::system_test! </span>{
        simulate.build(SkillType(<span class="number">2</span>));
        <span class="kw">_</span>: Player = (
            PositionX(<span class="number">0.0</span>),
            PositionY(<span class="number">0.0</span>),
            Direction(<span class="number">0.5</span>, <span class="number">0.5</span>),
        );
        <span class="kw">_</span>: Player = (
            PositionX(<span class="number">0.5</span>),
            PositionY(<span class="number">0.5</span>),
            Direction(<span class="number">0.5</span>, <span class="number">0.5</span>),
        );
    };

    simulate::call(
        <span class="kw-2">&amp;mut </span>counter,
        <span class="kw-2">&amp;</span>SkillType(<span class="number">2</span>),
        <span class="kw-2">&amp;mut </span>title,
        world.components.write_simple_storage(),
        world.components.write_simple_storage(),
        world.components.read_simple_storage(),
        world.components.read_partial_isotope_storage(<span class="kw-2">&amp;</span>[SkillType(<span class="number">3</span>)]),
    );

    <span class="macro">assert_eq!</span>(counter, <span class="number">1</span>);
    <span class="macro">assert_eq!</span>(title.<span class="number">0</span>, <span class="string">&quot;changed&quot;</span>);
}</code></pre></div>
</div></details></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="dynec" data-themes="" data-resource-suffix="" data-rustdoc-version="1.67.0-nightly (b7bc90fea 2022-11-21)" data-search-js="search-df80cc3cb87b6482.js" data-settings-js="settings-7e1cf5cc683233f7.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>